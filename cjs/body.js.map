{
  "version": 3,
  "sources": ["../esm/body.js"],
  "sourcesContent": ["\n/**\n * Body.js\n *\n * Body interface provides common methods for Request and Response\n */\n\nimport Stream, {PassThrough} from 'node:stream';\nimport {types, deprecate, promisify} from 'node:util';\nimport {Buffer} from 'node:buffer';\n\nimport Blob from '@esm2cjs/fetch-blob';\nimport {FormData, formDataToBlob} from '@esm2cjs/formdata-polyfill';\n\nimport {FetchError} from './errors/fetch-error.js';\nimport {FetchBaseError} from './errors/base.js';\nimport {isBlob, isURLSearchParameters} from './utils/is.js';\n\nconst pipeline = promisify(Stream.pipeline);\nconst INTERNALS = Symbol('Body internals');\n\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nexport default class Body {\n\tconstructor(body, {\n\t\tsize = 0\n\t} = {}) {\n\t\tlet boundary = null;\n\n\t\tif (body === null) {\n\t\t\t// Body is undefined or null\n\t\t\tbody = null;\n\t\t} else if (isURLSearchParameters(body)) {\n\t\t\t// Body is a URLSearchParams\n\t\t\tbody = Buffer.from(body.toString());\n\t\t} else if (isBlob(body)) {\n\t\t\t// Body is blob\n\t\t} else if (Buffer.isBuffer(body)) {\n\t\t\t// Body is Buffer\n\t\t} else if (types.isAnyArrayBuffer(body)) {\n\t\t\t// Body is ArrayBuffer\n\t\t\tbody = Buffer.from(body);\n\t\t} else if (ArrayBuffer.isView(body)) {\n\t\t\t// Body is ArrayBufferView\n\t\t\tbody = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n\t\t} else if (body instanceof Stream) {\n\t\t\t// Body is stream\n\t\t} else if (body instanceof FormData) {\n\t\t\t// Body is FormData\n\t\t\tbody = formDataToBlob(body);\n\t\t\tboundary = body.type.split('=')[1];\n\t\t} else {\n\t\t\t// None of the above\n\t\t\t// coerce to string then buffer\n\t\t\tbody = Buffer.from(String(body));\n\t\t}\n\n\t\tlet stream = body;\n\n\t\tif (Buffer.isBuffer(body)) {\n\t\t\tstream = Stream.Readable.from(body);\n\t\t} else if (isBlob(body)) {\n\t\t\tstream = Stream.Readable.from(body.stream());\n\t\t}\n\n\t\tthis[INTERNALS] = {\n\t\t\tbody,\n\t\t\tstream,\n\t\t\tboundary,\n\t\t\tdisturbed: false,\n\t\t\terror: null\n\t\t};\n\t\tthis.size = size;\n\n\t\tif (body instanceof Stream) {\n\t\t\tbody.on('error', error_ => {\n\t\t\t\tconst error = error_ instanceof FetchBaseError ?\n\t\t\t\t\terror_ :\n\t\t\t\t\tnew FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, 'system', error_);\n\t\t\t\tthis[INTERNALS].error = error;\n\t\t\t});\n\t\t}\n\t}\n\n\tget body() {\n\t\treturn this[INTERNALS].stream;\n\t}\n\n\tget bodyUsed() {\n\t\treturn this[INTERNALS].disturbed;\n\t}\n\n\t/**\n\t * Decode response as ArrayBuffer\n\t *\n\t * @return  Promise\n\t */\n\tasync arrayBuffer() {\n\t\tconst {buffer, byteOffset, byteLength} = await consumeBody(this);\n\t\treturn buffer.slice(byteOffset, byteOffset + byteLength);\n\t}\n\n\tasync formData() {\n\t\tconst ct = this.headers.get('content-type');\n\n\t\tif (ct.startsWith('application/x-www-form-urlencoded')) {\n\t\t\tconst formData = new FormData();\n\t\t\tconst parameters = new URLSearchParams(await this.text());\n\n\t\t\tfor (const [name, value] of parameters) {\n\t\t\t\tformData.append(name, value);\n\t\t\t}\n\n\t\t\treturn formData;\n\t\t}\n\n\t\tconst {toFormData} = await import('./utils/multipart-parser.js');\n\t\treturn toFormData(this.body, ct);\n\t}\n\n\t/**\n\t * Return raw response as Blob\n\t *\n\t * @return Promise\n\t */\n\tasync blob() {\n\t\tconst ct = (this.headers && this.headers.get('content-type')) || (this[INTERNALS].body && this[INTERNALS].body.type) || '';\n\t\tconst buf = await this.arrayBuffer();\n\n\t\treturn new Blob([buf], {\n\t\t\ttype: ct\n\t\t});\n\t}\n\n\t/**\n\t * Decode response as json\n\t *\n\t * @return  Promise\n\t */\n\tasync json() {\n\t\tconst text = await this.text();\n\t\treturn JSON.parse(text);\n\t}\n\n\t/**\n\t * Decode response as text\n\t *\n\t * @return  Promise\n\t */\n\tasync text() {\n\t\tconst buffer = await consumeBody(this);\n\t\treturn new TextDecoder().decode(buffer);\n\t}\n\n\t/**\n\t * Decode response as buffer (non-spec api)\n\t *\n\t * @return  Promise\n\t */\n\tbuffer() {\n\t\treturn consumeBody(this);\n\t}\n}\n\nBody.prototype.buffer = deprecate(Body.prototype.buffer, 'Please use \\'response.arrayBuffer()\\' instead of \\'response.buffer()\\'', 'node-fetch#buffer');\n\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n\tbody: {enumerable: true},\n\tbodyUsed: {enumerable: true},\n\tarrayBuffer: {enumerable: true},\n\tblob: {enumerable: true},\n\tjson: {enumerable: true},\n\ttext: {enumerable: true},\n\tdata: {get: deprecate(() => {},\n\t\t'data doesn\\'t exist, use json(), text(), arrayBuffer(), or body instead',\n\t\t'https://github.com/node-fetch/node-fetch/issues/1000 (response)')}\n});\n\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return Promise\n */\nasync function consumeBody(data) {\n\tif (data[INTERNALS].disturbed) {\n\t\tthrow new TypeError(`body used already for: ${data.url}`);\n\t}\n\n\tdata[INTERNALS].disturbed = true;\n\n\tif (data[INTERNALS].error) {\n\t\tthrow data[INTERNALS].error;\n\t}\n\n\tconst {body} = data;\n\n\t// Body is null\n\tif (body === null) {\n\t\treturn Buffer.alloc(0);\n\t}\n\n\t/* c8 ignore next 3 */\n\tif (!(body instanceof Stream)) {\n\t\treturn Buffer.alloc(0);\n\t}\n\n\t// Body is stream\n\t// get ready to actually consume the body\n\tconst accum = [];\n\tlet accumBytes = 0;\n\n\ttry {\n\t\tfor await (const chunk of body) {\n\t\t\tif (data.size > 0 && accumBytes + chunk.length > data.size) {\n\t\t\t\tconst error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, 'max-size');\n\t\t\t\tbody.destroy(error);\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\taccumBytes += chunk.length;\n\t\t\taccum.push(chunk);\n\t\t}\n\t} catch (error) {\n\t\tconst error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, 'system', error);\n\t\tthrow error_;\n\t}\n\n\tif (body.readableEnded === true || body._readableState.ended === true) {\n\t\ttry {\n\t\t\tif (accum.every(c => typeof c === 'string')) {\n\t\t\t\treturn Buffer.from(accum.join(''));\n\t\t\t}\n\n\t\t\treturn Buffer.concat(accum, accumBytes);\n\t\t} catch (error) {\n\t\t\tthrow new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, 'system', error);\n\t\t}\n\t} else {\n\t\tthrow new FetchError(`Premature close of server response while trying to fetch ${data.url}`);\n\t}\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed   instance       Response or Request instance\n * @param   String  highWaterMark  highWaterMark for both PassThrough body streams\n * @return  Mixed\n */\nexport const clone = (instance, highWaterMark) => {\n\tlet p1;\n\tlet p2;\n\tlet {body} = instance[INTERNALS];\n\n\t// Don't allow cloning a used body\n\tif (instance.bodyUsed) {\n\t\tthrow new Error('cannot clone body after it is used');\n\t}\n\n\t// Check that body is a stream and not form-data object\n\t// note: we can't clone the form-data object without having it as a dependency\n\tif ((body instanceof Stream) && (typeof body.getBoundary !== 'function')) {\n\t\t// Tee instance body\n\t\tp1 = new PassThrough({highWaterMark});\n\t\tp2 = new PassThrough({highWaterMark});\n\t\tbody.pipe(p1);\n\t\tbody.pipe(p2);\n\t\t// Set instance body to teed body and return the other teed body\n\t\tinstance[INTERNALS].stream = p1;\n\t\tbody = p2;\n\t}\n\n\treturn body;\n};\n\nconst getNonSpecFormDataBoundary = deprecate(\n\tbody => body.getBoundary(),\n\t'form-data doesn\\'t follow the spec and requires special treatment. Use alternative package',\n\t'https://github.com/node-fetch/node-fetch/issues/1167'\n);\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param {any} body Any options.body input\n * @returns {string | null}\n */\nexport const extractContentType = (body, request) => {\n\t// Body is null or undefined\n\tif (body === null) {\n\t\treturn null;\n\t}\n\n\t// Body is string\n\tif (typeof body === 'string') {\n\t\treturn 'text/plain;charset=UTF-8';\n\t}\n\n\t// Body is a URLSearchParams\n\tif (isURLSearchParameters(body)) {\n\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\n\t}\n\n\t// Body is blob\n\tif (isBlob(body)) {\n\t\treturn body.type || null;\n\t}\n\n\t// Body is a Buffer (Buffer, ArrayBuffer or ArrayBufferView)\n\tif (Buffer.isBuffer(body) || types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {\n\t\treturn null;\n\t}\n\n\tif (body instanceof FormData) {\n\t\treturn `multipart/form-data; boundary=${request[INTERNALS].boundary}`;\n\t}\n\n\t// Detect form data input from form-data module\n\tif (body && typeof body.getBoundary === 'function') {\n\t\treturn `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;\n\t}\n\n\t// Body is stream - can't really do much about this\n\tif (body instanceof Stream) {\n\t\treturn null;\n\t}\n\n\t// Body constructor defaults other things to string\n\treturn 'text/plain;charset=UTF-8';\n};\n\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param {any} obj.body Body object from the Body instance.\n * @returns {number | null}\n */\nexport const getTotalBytes = request => {\n\tconst {body} = request[INTERNALS];\n\n\t// Body is null or undefined\n\tif (body === null) {\n\t\treturn 0;\n\t}\n\n\t// Body is Blob\n\tif (isBlob(body)) {\n\t\treturn body.size;\n\t}\n\n\t// Body is Buffer\n\tif (Buffer.isBuffer(body)) {\n\t\treturn body.length;\n\t}\n\n\t// Detect form data input from form-data module\n\tif (body && typeof body.getLengthSync === 'function') {\n\t\treturn body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;\n\t}\n\n\t// Body is stream\n\treturn null;\n};\n\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param {Stream.Writable} dest The stream to write to.\n * @param obj.body Body object from the Body instance.\n * @returns {Promise<void>}\n */\nexport const writeToStream = async (dest, {body}) => {\n\tif (body === null) {\n\t\t// Body is null\n\t\tdest.end();\n\t} else {\n\t\t// Body is stream\n\t\tawait pipeline(body, dest);\n\t}\n};\n"],
  "mappings": "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",
  "names": ["Stream", "Blob"]
}
